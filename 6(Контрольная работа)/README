Анализ алгоритмов сортировки и поиска

1. Блочная (корзинная) сортировка (Bucket Sort)
Определение:
Блочная сортировка — это алгоритм, который распределяет элементы исходного массива на несколько корзин (или блоков) по диапазонам значений. Затем каждая корзина сортируется отдельно (тем же алгоритмом или другим, например вставками), а все корзины объединяются обратно в один отсортированный массив.
Как работает:
Сначала выбирается количество корзин, исходя из диапазона чисел. Каждый элемент помещается в свою корзину по функции распределения. После этого каждая корзина сортируется, и результат объединяется в общий список.
Сложность:
Средняя: O(n + k) (если данные равномерные и корзины сбалансированы)
Худшая: O(n²) (если все элементы попали в одну корзину)
Алгоритм эффективен, когда данные равномерно распределены, но может сильно замедлиться при смещённом распределении. Оптимален для чисел с плавающей точкой и при известном диапазоне значений.

2. Блинная сортировка (Pancake Sort)
Определение:
Блинная сортировка — это алгоритм, который сортирует массив с помощью переворотов его частей. Единственная разрешённая операция — «перевернуть» первые k элементов массива.
Как работает:
На каждом шаге ищется максимальный элемент в неотсортированной части массива. Сначала массив переворачивается так, чтобы этот элемент оказался первым, затем снова переворачивается — чтобы элемент встал в конец, на своё место. Процесс повторяется, пока массив не отсортируется.
Сложность:
Худшая и средняя: O(n²)
На каждом шаге алгоритм ищет максимум (O(n)) и выполняет переворот (O(n)), что даёт квадратичную сложность. Алгоритм используется в учебных целях и демонстрирует нестандартный подход к сортировке.

3. Сортировка бусинами (Bead Sort / Gravity Sort)
Определение:
Сортировка бусинами моделирует процесс падения бусин под действием гравитации. Каждый элемент массива представляется в виде ряда бусин, количество которых равно его значению. Бусины «падают вниз» по воображаемым стержням, а после оседания образуют отсортированный порядок.
Как работает:
Каждое число отображается в виде ряда единиц (бусин). Алгоритм пересчитывает столбцы, имитируя оседание бусин вниз — внизу оказываются большие значения. После «падения» строки считываются, формируя отсортированный массив.
Сложность:
Теоретическая: O(n)
Практическая: O(n * max(A))
Алгоритм очень наглядный, но ограничен — он подходит только для неотрицательных целых чисел. Скорость сильно зависит от величины максимального элемента.

4. Поиск скачками (Jump Search)
Определение:
Поиск скачками — это усовершенствованный вариант линейного поиска для отсортированных массивов. Алгоритм делает прыжки через определённое количество элементов (обычно √n), пока не найдёт диапазон, где может быть искомый элемент, а потом выполняет линейный поиск внутри этого диапазона.
Как работает:
Массив делится на блоки длиной √n. Алгоритм прыгает вперёд, пока текущий элемент не станет больше или равен искомому. Затем выполняется линейный поиск в предыдущем блоке, где потенциально находится элемент.
Сложность:
Средняя: O(√n)
Прыжки позволяют быстро сократить количество проверок. В худшем случае поиск требует n/√n = √n прыжков и ещё √n сравнений внутри блока, что даёт ту же оценку.

5. Экспоненциальный поиск (Exponential Search)
Определение:
Экспоненциальный поиск сочетает идеи последовательного и бинарного поиска. Сначала алгоритм быстро находит диапазон, в котором может находиться искомое значение, увеличивая границу в степенях двойки (1, 2, 4, 8, 16...), а затем выполняет бинарный поиск внутри найденного диапазона.
Как работает:
Сначала проверяется первый элемент. Если значение не найдено, алгоритм увеличивает индекс экспоненциально, пока не найдёт число большее или равное целевому. Затем вызывается бинарный поиск на найденном подотрезке.
Сложность:
Средняя и худшая: O(log n)
Первый этап занимает O(log i), где i — индекс элемента, а бинарный поиск добавляет ещё O(log i). Поэтому общая асимптотика остаётся логарифмической. Алгоритм эффективен при поиске в очень больших отсортированных массивах.

6. Тернарный поиск (Ternary Search)
Определение:
Тернарный поиск делит диапазон поиска на три части (в отличие от двух в бинарном поиске) и рекурсивно ищет значение в одной из трети массива, пока не найдёт совпадение или диапазон не сократится до нуля.
Как работает:
Определяются две точки деления (mid1 и mid2). Если искомое значение не равно ни одной из них, выбирается одна из трёх частей для продолжения поиска. Алгоритм повторяет процесс рекурсивно, сужая диапазон.
Сложность:
Средняя и худшая: O(log₃ n), что эквивалентно O(log n)
Хотя деление на три части кажется более быстрым, на практике тернарный поиск делает больше сравнений на каждом шаге, поэтому часто медленнее бинарного.
