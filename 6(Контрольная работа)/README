Анализ алгоритмов сортировки и поиска

1. Блочная (корзинная) сортировка (Bucket Sort)
Описание алгоритма:  
Алгоритм распределяет элементы по "корзинам" в зависимости от их значений, затем сортирует каждую корзину отдельно и объединяет результаты.

Ключевые элементы кода:
min(arr), max(arr) — функции нахождения минимального и максимального значения.
buckets = [[] for _ in range(bucket_count)] — генератор списков создаёт список пустых подсписков (корзин).
for num in arr: — стандартный цикл for, перебирающий элементы массива.
int() — преобразует дробное значение индекса корзины в целое.
buckets[index].append(num) — добавление элемента в соответствующую корзину.
sorted(bucket) — встроенная функция сортировки одной корзины.
extend() — добавляет содержимое корзины к итоговому списку.

Сложность:
Средняя: O(n + k) (если данные равномерные и корзины сбалансированы)
Худшая: O(n²) (если все элементы попали в одну корзину)
Анализ: Распределение O(n) + сортировка корзин O(Σm_i log m_i)
Алгоритм эффективен, когда данные равномерно распределены, но может сильно замедлиться при смещённом распределении. Оптимален для чисел с плавающей точкой и при известном диапазоне значений.

Проверка:
Исходный массив блочной сортировки: [0.78, 0.12, 0.23, 0.9, 0.56, 0.44]
Отсортированный массив блочной сортировки: [0.12, 0.23, 0.44, 0.56, 0.78, 0.9]

2. Блинная сортировка (Pancake Sort)
Описание алгоритма:  
Сортировка через последовательные перевороты частей массива, перемещая максимальные элементы в конец.

Ключевые элементы кода:
arr[:k+1] — срез списка, берёт часть массива от начала до k включительно.
reversed() — встроенная функция, переворачивает последовательность.
for size in range(n, 1, -1): — цикл от n до 2 с шагом -1, уменьшая область сортировки.
max(arr[:size]) — поиск максимума в неотсортированной части.
arr.index() — возвращает индекс найденного значения.
Вызовы flip(arr, ...) — функции-перевороты, переставляющие элементы.

Сложность:
Худшая и средняя: O(n²)
На каждом шаге алгоритм ищет максимум (O(n)) и выполняет переворот (O(n)), что даёт квадратичную сложность. Алгоритм используется в учебных целях и демонстрирует нестандартный подход к сортировке.
Анализ: O(n) поисков максимума × O(n) операций переворота

Проверка:
Исходный массив блинной сортировки: [3, 6, 1, 10, 2, 8]
Отсортированный массив блинной сортировки: [1, 2, 3, 6, 8, 10]

3. Сортировка бусинами (Bead Sort / Gravity Sort)
Определение:
Сортировка бусинами моделирует процесс падения бусин под действием гравитации. Каждый элемент массива представляется в виде ряда бусин, количество которых равно его значению. Бусины «падают вниз» по воображаемым стержням, а после оседания образуют отсортированный порядок.
Как работает:
Каждое число отображается в виде ряда единиц (бусин). Алгоритм пересчитывает столбцы, имитируя оседание бусин вниз — внизу оказываются большие значения. После «падения» строки считываются, формируя отсортированный массив.

Ключевые элементы кода:
any(x < 0 for x in arr) — генераторное выражение с проверкой отрицательных чисел.
grid = [[1]*num + [0]*(max_num - num) for num in arr] — создаёт матрицу, где 1 — бусина, 0 — пустое место.
Двойной цикл for j in range(max_num) и for i in range(len(arr)) моделирует падение бусин.
sum(row[j] for row in grid) — подсчёт количества бусин в колонке.
Тернарный оператор 1 if i >= len(arr) - beads else 0 заполняет ячейки снизу вверх.
sum(row) — подсчёт числа бусин в каждой строке для восстановления чисел.

Сложность:
Теоретическая: O(n)
Практическая: O(n * max(A))
Алгоритм очень наглядный, но ограничен — он подходит только для неотрицательных целых чисел. Скорость сильно зависит от величины максимального элемента.
Анализ: Зависит от максимального значения в массиве

Проверка:
Исходный массив сортировки бусинами: [5, 3, 1, 7, 4]
Отсортированный массив сортировки бусинами: [1, 3, 4, 5, 7]

4. Поиск скачками (Jump Search)
Определение:
Поиск скачками — это усовершенствованный вариант линейного поиска для отсортированных массивов. Алгоритм делает прыжки через определённое количество элементов (обычно √n), пока не найдёт диапазон, где может быть искомый элемент, а потом выполняет линейный поиск внутри этого диапазона.
Как работает:
Массив делится на блоки длиной √n. Алгоритм прыгает вперёд, пока текущий элемент не станет больше или равен искомому. Затем выполняется линейный поиск в предыдущем блоке, где потенциально находится элемент.

Ключевые элементы кода:
math.sqrt(n) — извлечение квадратного корня.
while prev < n and arr[min(step, n)-1] < target: — цикл, пока текущий элемент меньше нужного.
min(step, n) — защита от выхода за границы массива.
for i in range(prev, min(step, n)): — линейный поиск внутри блока.
return i — возвращает индекс найденного элемента или -1, если не найден.

Сложность:
Средняя: O(√n)
Прыжки позволяют быстро сократить количество проверок. В худшем случае поиск требует n/√n = √n прыжков и ещё √n сравнений внутри блока, что даёт ту же оценку.
Анализ: √n прыжков + √n проверок в блоке

Проверка:
Массив поиска скачками: [1, 3, 5, 7, 9, 11, 13]
Искомое значение поиска скачками: 9
Результат поиска скачками: 4

5. Экспоненциальный поиск (Exponential Search)
Определение:
Экспоненциальный поиск сочетает идеи последовательного и бинарного поиска. Сначала алгоритм быстро находит диапазон, в котором может находиться искомое значение, увеличивая границу в степенях двойки (1, 2, 4, 8, 16...), а затем выполняет бинарный поиск внутри найденного диапазона.
Как работает:
Сначала проверяется первый элемент. Если значение не найдено, алгоритм увеличивает индекс экспоненциально, пока не найдёт число большее или равное целевому. Затем вызывается бинарный поиск на найденном подотрезке.

Ключевые элементы кода:
while left <= right: — основной цикл бинарного поиска.
(left + right) // 2 — целочисленное деление для нахождения середины диапазона.
i *= 2 — умножение с присваиванием, удваивает шаг на каждой итерации.
min(i, len(arr)-1) — защита от выхода за пределы массива.
binary_search() — отдельная функция для повторного использования.

Сложность:
Средняя и худшая: O(log n)
Первый этап занимает O(log i), где i — индекс элемента, а бинарный поиск добавляет ещё O(log i). Поэтому общая асимптотика остаётся логарифмической. Алгоритм эффективен при поиске в очень больших отсортированных массивах.
Анализ: O(log n) на расширение + O(log n) на бинарный поиск

Проверка:
Массив экспоненциального поиска: [2, 4, 6, 8, 10, 12, 14, 16]
Искомое значение экспоненциального поиска: 10
Результат экспоненциального поиска: 4

6. Тернарный поиск (Ternary Search)
Определение:
Тернарный поиск делит диапазон поиска на три части (в отличие от двух в бинарном поиске) и рекурсивно ищет значение в одной из трети массива, пока не найдёт совпадение или диапазон не сократится до нуля.
Как работает:
Определяются две точки деления (mid1 и mid2). Если искомое значение не равно ни одной из них, выбирается одна из трёх частей для продолжения поиска. Алгоритм повторяет процесс рекурсивно, сужая диапазон.

Ключевые элементы кода:
if right >= left: — базовое условие рекурсии, пока диапазон не сузился.
(right - left) // 3 — вычисление трети диапазона.
mid1, mid2 — границы трёх поддиапазонов.
return ternary_search(...) — рекурсивный вызов с новым диапазоном.
Ветвления if / elif / else выбирают, в какой трети искать дальше.

Сложность:
Средняя и худшая: O(log₃ n), что эквивалентно O(log n)
Хотя деление на три части кажется более быстрым, на практике тернарный поиск делает больше сравнений на каждом шаге, поэтому часто медленнее бинарного.
Анализ: На каждом шаге область поиска уменьшается в 3 раза

Проверка:
Массив тернарного поиска: [1, 2, 4, 5, 7, 9, 11]
Искомое значение тернарного поиска: 9
Результат тернарного поиска: 5
