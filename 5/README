1. Сортировка выбором (Selection Sort)

Алгоритм проходит по массиву, находит минимальный элемент и ставит его на первую позицию. Затем выбирает следующий минимальный элемент и ставит его на вторую позицию. Процесс продолжается, пока весь массив не будет отсортирован.

Принцип работы:
Внешний цикл for (int i = 0; i < n - 1; i++) отвечает за выбор позиции, куда будет помещён следующий минимальный элемент.
Во внутреннем цикле for (int j = i + 1; j < n; j++) происходит поиск минимального элемента в оставшейся части массива.
Когда минимальный элемент найден, выполняется обмен значениями через временную переменную temp.

Сложность алгоритма: O(n²).
Зависит от двух вложенных циклов, каждый из которых в худшем случае проходит весь массив.

Исходный массив: 64 25 12 22 11
Отсортированный массив: 11 12 22 25 64

2. Сортировка пузырьком (Bubble Sort)

Этот метод основан на многократном проходе по массиву. На каждом проходе соседние элементы сравниваются, и если они расположены неправильно, происходит обмен. После каждого прохода самый большой элемент "всплывает" в конец массива.

Принцип работы:
Внешний цикл for (int i = 0; i < n - 1; i++) задаёт количество проходов по массиву.
Внутренний цикл for (int j = 0; j < n - i - 1; j++) сравнивает соседние элементы arr[j] и arr[j + 1].
Если arr[j] > arr[j + 1], выполняется обмен значениями.
Если за один проход не произошло ни одного обмена (флаг swapped остался ложным), сортировка завершается досрочно.

Сложность алгоритма: O(n²).
В худшем случае требуется n² сравнений, но при почти отсортированном массиве работает быстрее.

Исходный массив: 64 34 25 12 22 11 90
Отсортированный массив: 11 12 22 25 34 64 90

3. Сортировка вставками (Insertion Sort)

Массив делится на отсортированную и неотсортированную части. На каждом шаге берётся элемент из неотсортированной части и вставляется в нужное место в отсортированной.

Принцип работы:
Цикл for i in range(1, len(arr)) перебирает элементы массива начиная со второго.
Текущий элемент сохраняется в переменной key, а переменная j указывает на индекс предыдущего элемента.
Пока arr[j] > key, элементы сдвигаются вправо (arr[j + 1] = arr[j]), а j уменьшается.
Когда найдено нужное место, элемент key вставляется (arr[j + 1] = key).

Сложность алгоритма: O(n²).
Каждый элемент может быть перемещён через весь массив, особенно при обратной сортировке.

Исходный массив: 12 11 13 5 6
Отсортированный массив: 5 6 11 12 13

4. Сортировка слиянием (Merge Sort)

Метод делит массив на две части, рекурсивно сортирует каждую из них и объединяет в один отсортированный массив.

Принцип работы:
Функция mergeSort делит массив пополам (mid = (left + right) / 2), сортирует обе половины и вызывает merge для их объединения.
Функция merge создаёт два временных массива L и R, копирует туда элементы, а затем сливает их обратно в основной массив, сравнивая поэлементно.
После завершения всех уровней рекурсии массив оказывается отсортированным.

Сложность алгоритма: O(n log n).
Каждое деление массива даёт уровень рекурсии, а объединение на каждом уровне требует O(n).

Исходный массив: 38 27 43 3 9 82 10
Отсортированный массив: 3 9 10 27 38 43 82

5. Сортировка Шелла (Shell Sort)

Улучшенный вариант сортировки вставками, где элементы сравниваются не с соседями, а через определённое расстояние — шаг gap.

Принцип работы:
Начальный шаг вычисляется как gap = len(arr) // 2.
Для каждого шага выполняется проход по массиву, где элементы сравниваются и переставляются так, чтобы упорядочить подгруппы.
После каждой итерации шаг делится пополам (gap //= 2) и процесс повторяется, пока gap не станет равен 1.

Сложность алгоритма: от O(n log n) до O(n²) в зависимости от выбора последовательности шагов.

Исходный массив: 64 34 25 12 22 11 90
Отсортированный массив: 11 12 22 25 34 64 90

6. Быстрая сортировка (Quick Sort)

Один из самых эффективных алгоритмов. Работает по принципу "разделяй и властвуй": выбирает опорный элемент, делит массив на элементы меньше и больше него, а затем рекурсивно сортирует обе части.

Принцип работы:
Функция partition выбирает последний элемент как опорный (pivot = arr[high]) и переставляет элементы так, чтобы слева оказались меньшие, а справа — большие.
Функция quickSort вызывает себя рекурсивно для левой и правой частей массива, пока подмассивы не станут длиной 1.

Сложность алгоритма: в среднем O(n log n), в худшем случае — O(n²).

Исходный массив: 10 7 8 9 1 5
Отсортированный массив: 1 5 7 8 9 10

7. Пирамидальная сортировка (Heap Sort)

Сначала из массива создаётся бинарная куча (max-heap), где каждый родитель больше своих потомков. Затем из кучи последовательно извлекаются максимальные элементы и помещаются в конец массива.

Принцип работы:
Функция heapify восстанавливает свойство кучи для поддерева, начиная с заданного корня.
Основная функция heapSort сначала строит кучу (for (int i = n / 2 - 1; i >= 0; i--) heapify(...)), затем извлекает корень и помещает его в конец массива, уменьшая размер кучи.
После каждого извлечения структура пересобирается для поддержания порядка.

Сложность алгоритма: O(n log n).
Каждое извлечение требует логарифмическое время, а таких извлечений — n.

Исходный массив: 12 11 13 5 6 7
Отсортированный массив: 5 6 7 11 12 13

8. Линейный поиск (Linear Search)

Простейший метод поиска, при котором элементы массива проверяются поочерёдно, пока не найден нужный или не закончится массив.

Принцип работы:
Цикл for (int i = 0; i < arr.length; i++) проходит по каждому элементу.
Если arr[i] == target, возвращается индекс i.
Если цикл завершается без совпадения — возвращается -1.

Сложность алгоритма: O(n).
Каждый элемент проверяется один раз.

Массив: 3 7 1 9 5
Элемент 9 найден на индексе 3

9. Бинарный поиск (Binary Search)

Бинарный поиск работает только с отсортированным массивом. Диапазон поиска делится пополам, и на каждом шаге отбрасывается половина элементов.

Принцип работы:
Задаются границы поиска: low = 0, high = len(arr) - 1.
В цикле while low <= high вычисляется средний индекс mid = (low + high) // 2.
Если arr[mid] < x, поиск продолжается в правой половине (low = mid + 1).
Если arr[mid] > x, поиск идёт в левой (high = mid - 1).
Если найдено совпадение — возвращается индекс mid.

Сложность алгоритма: O(log n).

Массив: 2 3 5 7 11 13 17 19 23 29
Элемент 11 найден на индексе 4

10. Интерполяционный поиск (Interpolation Search)

Более точная версия бинарного поиска, которая оценивает позицию искомого элемента по значению, предполагая, что данные распределены равномерно.

Принцип работы:
Задаются границы low и high.
Позиция элемента вычисляется по формуле
pos = low + ((x - arr[low]) * (high - low)) / (arr[high] - arr[low]).
Далее алгоритм сравнивает элемент на позиции pos с искомым и сужает диапазон поиска аналогично бинарному методу.

Сложность алгоритма: O(log log n) для равномерных массивов, в худшем случае — O(n).

Массив: 10 12 13 16 18 19 20 21 22 23 24 33 35 42 47
Элемент 18 найден на позиции 4

11. Поиск Фибоначчи (Fibonacci Search)

Использует числа Фибоначчи для определения диапазона поиска. По принципу похож на бинарный поиск, но с делением на части, заданные последовательностью Фибоначчи.

Принцип работы:
Сначала находятся числа Фибоначчи, где F(m) — минимальное число, большее длины массива.
Далее определяется индекс проверки i = min(offset + F(m−2), len(arr) - 1).
Если arr[i] < x, диапазон сдвигается вправо, если arr[i] > x — влево.
Поиск продолжается, пока не останется одно число, или пока не найден элемент.

Сложность алгоритма: O(log n).

Массив: 10 22 35 40 45 50 80 82 85 90 100
Элемент 85 найден на индексе 8
