1. Сортировка выбором (Selection Sort)
Алгоритм последовательно ищет минимальный элемент среди неотсортированных и помещает его в начало массива. После каждой итерации отсортированная часть увеличивается на один элемент.

Механизм работы:

* Внешний цикл выбирает позицию, на которую нужно поставить очередной минимум.
* Внутренний цикл находит этот минимум среди оставшихся элементов.
* Элементы меняются местами через функцию `swap`.

Сложность: O(n²)
Обоснование: два вложенных цикла по n операций.
Пример:
Исходный массив: 64 25 12 22 11
Результат: 11 12 22 25 64


2. Сортировка пузырьком (Bubble Sort)
Простейший алгоритм сортировки, основанный на последовательных попарных сравнениях соседних элементов. При каждом проходе наибольший элемент «всплывает» в конец массива.

Механизм работы:

* Внешний цикл управляет количеством проходов.
* Внутренний цикл сравнивает соседние элементы и меняет их местами при необходимости.
* После каждого прохода наибольший элемент фиксируется в конце.

Сложность: O(n²)
Обоснование: количество операций растёт квадратично из-за вложенных циклов.
Пример:
Исходный массив: 64 34 25 12 22 11 90
Результат: 11 12 22 25 34 64 90


3. Сортировка вставками (Insertion Sort)
Метод основан на постепенном формировании отсортированной части массива: каждый новый элемент вставляется в нужную позицию среди уже упорядоченных.

Механизм работы:

* Первый элемент считается отсортированным.
* Для каждого следующего элемента выполняется поиск позиции вставки.
* При необходимости элементы сдвигаются вправо.

Сложность: O(n²)
Обоснование: в худшем случае каждый элемент сравнивается со всеми предыдущими.
Пример:
Исходный массив: 38 27 43 3 9 82 10
Результат: 3 9 10 27 38 43 82


4. Сортировка слиянием (Merge Sort)
Эффективный алгоритм «разделяй и властвуй». Массив делится на две части, каждая сортируется рекурсивно, затем происходит их слияние в общий отсортированный массив.

Механизм работы:

* Деление массива до подмассивов длиной 1.
* Рекурсивная сортировка каждой половины.
* Слияние через вспомогательную функцию `merge`.

Сложность: O(n log n)
Обоснование: log n уровней деления, на каждом уровне — O(n) операций.
Пример:
Исходный массив: 38 27 43 3 9 82 10
Результат: 3 9 10 27 38 43 82


5. Сортировка Шелла (Shell Sort)
Оптимизированный вариант сортировки вставками. Элементы сравниваются не только с соседями, а через заданный интервал (gap), который постепенно уменьшается до 1.

Механизм работы:

* На первом этапе массив делится на подгруппы по шагу `gap`.
* В каждой подгруппе выполняется сортировка вставками.
* Шаг уменьшается до 1, выполняется финальная сортировка.

Сложность: зависит от выбора последовательности шагов, в среднем O(n log n).
Пример:
Результат: [11, 12, 22, 25, 34, 64, 90]


6. Быстрая сортировка (Quick Sort)
Один из самых эффективных алгоритмов общего назначения. Делит массив на две части относительно опорного элемента (pivot): слева — меньшие, справа — большие. Далее обе части сортируются рекурсивно.

Механизм работы:

* Функция `partition` выполняет перераспределение элементов.
* Рекурсивная сортировка левой и правой частей.
* Базовый случай — массив длиной 0 или 1.

Сложность: O(n log n) в среднем, O(n²) в худшем случае.
Пример:
Исходный массив: 10 7 8 9 1 5
Результат: 1 5 7 8 9 10


7. Пирамидальная сортировка (Heap Sort)
Метод основан на структуре данных «бинарная куча» (heap). Алгоритм сначала строит max-heap, затем поочередно извлекает максимальный элемент и помещает его в конец массива.

Механизм работы:

* Построение бинарной кучи.
* Извлечение корневого элемента и перестройка кучи.
* Повтор до полного упорядочивания.

Сложность: O(n log n)
Обоснование: построение кучи — O(n), дальнейшие извлечения — O(n log n).
Пример:
Исходный массив: [12, 11, 13, 5, 6, 7]
Результат: [5, 6, 7, 11, 12, 13]


8. Линейный поиск (Linear Search)
Простейший метод поиска, при котором элементы массива проверяются по очереди до нахождения нужного значения.

Механизм работы:

* Последовательный проход по всем элементам.
* Сравнение текущего значения с искомым.
* При совпадении возвращается индекс, иначе — -1.

Сложность: O(n)
Обоснование: в худшем случае требуется просмотр всех элементов.
Пример: элемент найден на позиции 3.


9. Бинарный поиск (Binary Search)
Эффективный способ поиска в отсортированном массиве, использующий принцип деления диапазона пополам.

Механизм работы:

* Определяется середина массива.
* Сравнивается значение среднего элемента с искомым.
* В зависимости от результата диапазон поиска сокращается вдвое.

Сложность: O(log n)
Обоснование: на каждом шаге диапазон уменьшается в 2 раза.
Пример: элемент 11 найден на индексе 4.


10. Интерполяционный поиск (Interpolation Search)
Модификация бинарного поиска, применимая к равномерно распределённым данным. Позиция для проверки вычисляется не по середине, а по приближённой формуле.

Механизм работы:

* Расчёт позиции по формуле:
  `pos = low + ((value - arr[low]) * (high - low)) / (arr[high] - arr[low])`.
* Проверка значения и уточнение диапазона.

Сложность: O(log log n) при равномерном распределении данных.
Пример: элемент 18 найден на индексе 4.


11. Поиск Фибоначчи (Fibonacci Search)
Алгоритм основан на числах Фибоначчи, которые используются для деления массива на интервалы поиска.

Механизм работы:

* Находится наименьшее число Фибоначчи, большее размера массива.
* Проверяется элемент на позиции, определяемой этим числом.
* В зависимости от результата диапазон поиска сужается.

Сложность: O(log n)
Обоснование: число итераций пропорционально логарифму размера массива.
Пример: элемент 85 найден на индексе 8.
