Вариант 5. Покрытие множеств с жадным алгоритмом
Задача: реализовать жадный ln(n)-аппроксимационный алгоритм для задачи о покрытии
множеств.
Требования:
- Входные данные: универсальное множество и семейство подмножеств
- Выход: минимальное количество выбранных множеств
- Вывести выбранные множества и общее количество элементов
Входные данные:
Универсум: {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
Подмножества: S1={1,2,3}, S2={2,4,6}, S3={3,5,7},
 S4={1,4,7,10}, S5={5,6,8,9}

Описание алгоритма:

Пока есть элементы, которые ещё не покрыты:
Пойми, какое подмножество добавит максимальное количество новых (ещё не покрытых) элементов.
Выбери это подмножество в решение.
Удали покрытые им элементы из множества "непокрытых".
Возвращаем набор выбранных множеств и объединение их элементов.

Синтаксис:

set(...) — создание множества. Поддерживает & (пересечение), | (объединение), - (разность).
dict (словарь) — хранит пары имя: множество.
for name, s in subsets.items() — итерация по парам ключ-значение словаря.
len(s) — размер множества.
while uncovered: — цикл, выполняется пока условие истинно (пустое множество считается False).
list.append(x) — добавление в список.
set.update(other_set) — добавляет элементы другого множества.
uncovered -= best_set_elements — вычитание множества (удаление всех элементов best_set_elements из uncovered).
return — возвращает результат из функции.

Временная сложность: O(m · n²) в худшем случае, где m — количество подмножеств, n — размер универсума.
Анализ: Алгоритм на каждой итерации перебирает все m множеств и вычисляет пересечения с непокрытыми элементами (O(m·n)), при до n итерациях цикла, что даёт итоговую сложность O(m·n²).
